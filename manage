#!/usr/bin/env python3
"""Manage dotfiles

This script is used to manage dotfiles.
"""

import os
import sys
import shlex
import subprocess
import contextlib

try:
    import click
except Exception:
    click = None
else:
    if not click.__version__.startswith("6."):
        click = None

if click is None:
    print(
        "Please run `pip install 'click>=6.0.0'` since this script depends on "
        "click for it's command line interface."
    )
    sys.exit(1)


HOME_DIR = os.path.expanduser('~')
THIS_DIR = os.path.dirname(__file__) or "."
ACTION_COLOR_DICT = {
    'backup': 'magenta',
    'create': 'green',
    'remove': 'red',
    'skip': 'yellow',
    'up to date': 'green',
    'update': 'blue',
    # For check
    'good': 'green',
    'not good': 'red',
    'warn': 'yellow',
}


# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------
class Logger(object):

    def __init__(self):
        super().__init__()
        self._indent = 0

    def _m(self, message, *args, **kwargs):
        # A shorthand for brevity
        if isinstance(message, str):
            return " " * self._indent + message.format(*args, **kwargs)
        else:
            return " " * self._indent + repr(message)

    def debug(self, message, *args, **kwargs):
        if DRY_RUN:
            self.info(message, *args, **kwargs)

    def status(self, message, *args, **kwargs):
        click.secho(self._m(message, *args, **kwargs), fg='magenta')

    def info(self, message, *args, **kwargs):
        click.secho(self._m(message, *args, **kwargs))

    def error(self, message, *args, **kwargs):
        click.secho(self._m('ERROR: ' + message, *args, **kwargs), fg='red')

    def success(self, message, *args, **kwargs):
        click.secho(self._m(message, *args, **kwargs), fg='green')

    def spaced_status(self, action, target):
        colour = ACTION_COLOR_DICT.get(action, None)
        if colour is None:
            self.error(
                "Got unknown action for logger - {}; will continue though",
                action
            )

        s = click.style("[" + action.center(10) + "]", fg=colour)
        self.info('{} {}', s, target)


class ListFile(object):
    """A hash-commented file with one item per line.
    """

    def __init__(self, file_name):
        super().__init__()
        self.file_name = file_name
        self._initialized = False

        self._file = None

    def __iter__(self):
        if self._initialized:
            return self
        self._initialized = True

        try:
            self.file = open(self.file_name)
        except FileNotFoundError:
            log.error('ERROR: Could not load file: {}', self.file_name)
            raise

        return self

    def __next__(self):
        while True:
            line = next(self.file)
            # Stop if reached EOF
            if not line:
                self.file.close()
                raise StopIteration

            # If the first character is a '#' or it is an empty line, skip
            line = line.strip()
            if line[0:1] in ['', '#']:  # Comment
                continue
            else:
                return line

    def for_every(self, function):

        def show_progress_counter(items, function):
            total_items = len(items)
            for i, item in enumerate(items):
                log.info('... {} of {}: {}', i + 1, total_items, item)
                function(item)

        items = list(self)

        if items is not None:
            show_progress_counter(items, function)


@contextlib.contextmanager
def task(message):
    click.secho('# {}...'.format(message), fg='blue')
    try:
        yield
    except Exception:
        log.error('Aborting due to following error...')
        raise
    else:
        click.secho('# Completed', fg='blue')


def run(command, repo):
    if repo.verbose:
        log.info('> {}', command)
    if repo.dry_run:
        return 0
    return subprocess.call(shlex.split(command))


# ------------------------------------------------------------------------------
# Handling Symlinks
# ------------------------------------------------------------------------------
class DotFilesRepo(object):

    def __init__(self, source_dir, target_dir, walk_depth, verbose, dry_run):
        super().__init__()
        self.global_action = None
        self.source_dir = os.path.abspath(source_dir)
        self.target_dir = os.path.abspath(target_dir)
        self.walk_depth = walk_depth
        self.verbose = verbose
        self.dry_run = dry_run

    def link_source_to_target(self, source, target):
        run('mkdir -p "{}"'.format(os.path.dirname(target)), self)
        run('ln -s "{}" "{}"'.format(source, target), self)

    def get_action(self, target):
        if self.global_action is not None:
            return self.global_action

        # Mapping of options to return values
        mapping = {
            's': 'skip',
            'b': 'backup',
            'u': 'update (overwrite)',
        }

        # Prepare Prompt
        options = []
        for val in mapping.values():
            options.append('[{}]{}'.format(val[0], val[1:]))
            options.append('[{}]{} all'.format(val[0].upper(), val[1:]))

        prompt_text = (
            'File already exists: {}, '.format(target) +
            'what do you want to do?\n' +
            ', '.join(options)
        )

        # Show Prompt
        click.echo(prompt_text)

        # Get and validate input
        action = ' '
        while action.lower() not in mapping:
            action = click.getchar()
            click.echo(action)

        # Set the action
        val = mapping[action.lower()].split()[0]

        if action.isupper():
            self.global_action = val

        return val

    def find_files_to_symlink(self, topics):
        walk_dir = self.source_dir.rstrip(os.path.sep)
        base_depth = walk_dir.count(os.path.sep)
        # assert os.path.isdir(walk_dir)
        # if topics and 'base' not in topics:
        #     log.info('Adding topic {!r}', 'base')

        for root, dirs, files in os.walk(walk_dir):
            current_depth = root.count(os.path.sep)

            # Filter topics
            # if current_depth == 0 and topics:
            #     for item in dirs[:]:
            #         if item not in topics:
            #             dirs.remove(item)
            #             log.info('Skipping topic: {}'.format(item))

            # Skip .git folders
            if '.git' in dirs:
                dirs.remove('.git')

            # yield things to be symlinked
            for item in dirs + files:
                if item.endswith('.symlink'):
                    yield os.path.join(os.path.relpath(root, walk_dir), item)

            # Ensure we don't recurse more than the allowed limit
            if current_depth >= base_depth + self.walk_depth:
                del dirs[:]

    def compute_target(self, rel_path):
        topic, *parts = rel_path.split(os.sep)
        # Prefix a '.'
        parts[0] = '.' + parts[0]
        # Remove the '.symlink' portion
        parts[-1] = parts[-1][:-len('.symlink')]
        return os.path.join(self.target_dir, *parts)

    def backup_file(self, fname):
        run('mv "{0}" "{0}.backup"'.format(fname), self)

    def remove_file(self, fname):
        run('rm "{}"'.format(fname), self)

    def sync(self, topics):
        """Symlinks the dotfiles in the source_dir with target_dir

        Structure of dotfiles:
          - topic-1/
            - content-file-1.shrc
            - content-file-2.symlink
            - content-file-3.zsh
          - topic-2/
            - content-file-1.shrc
            - content-file-2.symlink
            - content-file-3.zsh
        """
        if not self.dry_run:
            # Write the location of the dotfiles repository in a file
            path = os.path.join(self.target_dir, '.dotfiles-dir')
            with open(path, 'w') as f:
                f.write(self.source_dir)

        for rel_path in self.find_files_to_symlink(topics):
            source = os.path.join(self.source_dir, rel_path)

            target = self.compute_target(rel_path)

            # Determine what to do with target
            if not os.path.exists(target):
                action = 'create'
            elif os.path.islink(target):
                if os.readlink(target) == source:  # link is up to date
                    action = 'up to date'
                else:  # link needs updating
                    action = 'update'
            else:
                action = self.get_action(target)

            if target.startswith(HOME_DIR + os.sep):
                status_target = "~" + target[len(HOME_DIR):]
            else:
                status_target = target
            log.spaced_status(action, status_target)

            # Take the required action
            if action in ['skip', 'up to date']:
                continue  # no action needed.
            elif action == 'backup':
                self.backup_file(target)
            elif action == 'update':
                self.remove_file(target)

            self.link_source_to_target(source, target)

    def is_broken_symlink(self, path):
        return os.path.islink(path) and not os.path.exists(path)

    def clean(self):
        """Removes stale symlinks from target_dir
        """
        for item in os.listdir(self.target_dir):
            path = os.path.join(self.target_dir, item)
            # If symlink is broken
            if self.is_broken_symlink(path):
                run('rm "{}"'.format(path), self)
                log.file_status('remove', path)


# ------------------------------------------------------------------------------
# Checking the system setup
# ------------------------------------------------------------------------------
class SystemChecker(object):
    """Implements helpers for checking the system configuration
    """

    def __init__(self):
        super().__init__()
        self._logger = Logger()

    def _log_msg(self, result, msg):
        assert result in {"good", "not good", "warn"}
        self._logger.spaced_status(result, msg)

    @property
    def is_mac(self):
        return sys.platform == 'darwin'

    @property
    def is_linux(self):
        return sys.platform.startswith('linux')


    def equal(self, *, expected, should_warn=False, **kwargs):
        assert len(kwargs) == 1, "expected only 2 kwargs"

        name, value = next(iter(kwargs.items()))
        if value == expected:
            self._log_msg(
                "good",
                "{} is {!r}".format(name, expected)
            )
        else:
            self._log_msg(
                "warn" if should_warn else "not good",
                "{} is not {!r}, it is {!r}".format(name, expected, value)
            )


# ------------------------------------------------------------------------------
# CLI
# ------------------------------------------------------------------------------
@click.group()
@click.option(
    '--src-dir', type=click.Path(exists=True), default=THIS_DIR,
    help="Location to use as dotfiles directory"
)
@click.option(
    '--dest-dir', type=click.Path(exists=True), default=HOME_DIR,
    help="Location to create symlinks"
)
@click.option(
    '-n', '--dry-run', default=False, is_flag=True,
    help='Enable debugging mode (implies --verbose)'
)
@click.option(
    '--depth', default=3, type=int,
    help='How deep to recurse looking for ".symlink" items'
)
@click.option(
    '-v', '--verbose', default=False, is_flag=True,
    help='Show what commands have been executed.'
)
@click.pass_context
def cli(ctx, src_dir, dest_dir, dry_run, depth, verbose):
    if dry_run:
        verbose = True

    ctx.obj['obj'] = DotFilesRepo(src_dir, dest_dir, depth, verbose, dry_run)
    ctx.obj['verbose'] = verbose


@cli.command()
@click.argument('topics', nargs=-1)
@click.pass_context
def sync(ctx, topics):
    """Update the symlinks
    """
    with task('Syncing dotfiles'):
        ctx.obj['obj'].sync(topics)


@cli.command()
@click.pass_context
def clean(ctx):
    """Removes stale/broken symlinks
    """
    with task('Cleaning broken symlinks'):
        ctx.obj['obj'].clean()


@cli.command()
@click.pass_context
def check(ctx):
    """Check whether a system is setup correctly.

    NOTE: This is obviously opinionated. :)
    TODO: Implement all these checks

    - Identity:
        - username
        - GPG key
        - SSH key
    - Git:
        - git > 2.0.0 (prefer latest)
        - Name
        - Email
        - GPG signed of commits by default

    - Android Studio
    - Python:
        - (TODO: look into pyenv)
        - Python 2 (> 2.7.9)
        - Python 3 (> 3.3)
        - pip
        - virtualenvwrapper
        - NumPy
        - OpenCV
    - Ruby:
        - rbenv
        - gem
        - bundler
    - Javascript:
        - nodeenv
        - npm
    - Web Tools:
        - sass
    - Virtual Machines:
        - VirtualBox
        - Vagrant

    - default shell = ZSH
    - Nerd Fonts:
        - ensure a Nerd Font is installed
        - active in VS Code (if installed)
        - active in Sublime Text (if installed)

    - MacOS:
        (from https://github.com/mathiasbynens/dotfiles/blob/398496c2372d65c0e6770d02b0c5b49c0d636f31/.macos)
        - ensure XCode CLI tools are installed
        - brew is installed
        - save panel expanded by default
        - smart dashes disabled
        - screenshots go in a screenshots folder
        - status bar is enabled
        - safari: full URL
        - safari: don't auto open "safe" files
        - settings: need admin password to modify system settings
        - settings: firewall is on
    - Debian:
        - apt
        - screenshots go in a screenshots folder
    """
    # check if CLI tools are installed
    # pkgutil --pkg-info=com.apple.pkg.CLTools_Executables
    checker = SystemChecker()

    checker.equal(username=os.environ["USER"], expected="pradyunsg")

def main():
    cli(obj={}, auto_envvar_prefix='DOTFILES')


# Some globals for nicer handling of the world
log = Logger()

if __name__ == '__main__':
    main()
