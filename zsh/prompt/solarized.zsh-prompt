# A solarized theme for ZSH
#
# A simple prompt which shows contextual-information only when relevant.
#
# Information:
#     - User name
#     - Name of virtualenv
#     - Number of background jobs (if any)
#     - Current directory
#     - Git (if in git repository)
#         - Branch name or (if detached) commit hash
#         - Deviation from tracking branch and amount of divergence (if deviated)
#         - Shows counts of modified, deleted, untracked and unmerged files
#     + New line
#     - Prompt
#         - Red if last command failed, otherwise Green

# Symbols
declare -A SYMBOLS

SYMBOLS[separator]="⮀"

SYMBOLS[background_job_count]="⚙"

SYMBOLS[git_deviation_ahead]="⇡"
SYMBOLS[git_deviation_behind]="⇣"

SYMBOLS[git_upstream_pointer]="↠"
SYMBOLS[git_branch_name_prefix]="⭠"
SYMBOLS[git_hash_prefix]=":"

SYMBOLS[git_deleted_file]="-"
SYMBOLS[git_modified_file]="✎"
SYMBOLS[git_unmerged_file]="×"
SYMBOLS[git_untracked_file]="?"

# Text colors
declare -A text_color

text_color[user_name]="166"
text_color[virtualenv_name]="255"
text_color[background_job_count]="166"
text_color[current_directory]="166"
text_color[git]="255"

# Git colors
text_color[git_branch_name_prefix]="234"
text_color[git_branch_name]="237"
text_color[git_upstream_pointer]="234"
text_color[git_upstream_name]="237"

text_color[git_deviation_ahead]="1"
text_color[git_deviation_behind]="1"

text_color[git_hash]="1"

text_color[git_deleted_file]="52"
text_color[git_modified_file]="94"
text_color[git_unmerged_file]="1"
text_color[git_untracked_file]="1"

# Prompt colors
#  %(0?.success.failure)
text_color[prompt]="%(0?.22.160)"

#------------------------------------------------------------------------------
# Color Management Functions
#------------------------------------------------------------------------------
# Foreground
function colorize_text() {
    # $1 -> Color, $2 -> Text
    print -n "%{\e[38;5;$1m%}$2%{\e[39m%}"
}

#------------------------------------------------------------------------------
# Git
#------------------------------------------------------------------------------
function _prompt_segment_git() {
    # # Verify that we have git
    # command -v git >/dev/null 2>&1 || return

    # Only add information if we are in a repository
    git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return

    # HEAD related information
    git_HEAD_ref=$(git symbolic-ref HEAD 2> /dev/null)
    if [[ $git_HEAD_ref =~ "refs/heads/.*" ]]; then
        git_head_status="$(_prompt_git_branch_upstream_info)"
    else
        git_head_status="$(_prompt_git_detached_HEAD_info)"
    fi

    # Working Directory information
    git_working_dir_status="$(_prompt_git_working_dir_info)"
    git_segment_text="$git_head_status"
    if [[ -n $git_working_dir_status ]]; then
        git_segment_text+="$git_working_dir_status"
    fi
    # Return the text for the git segments
    print -n "$git_segment_text"
}

function _prompt_git_working_dir_info() {
    deleted=$(git ls-files -d | wc -l)
    modified=$(git ls-files -m | wc -l)
    unmerged=$(git ls-files -u | wc -l)
    untracked=$(git ls-files -o | wc -l)

    retval=
    if (( ${untracked} > 0 )); then
        colorize_text $text_color[git_untracked_file] "$SYMBOLS[git_untracked_file]${untracked}"
        print " "
    fi
    if (( ${unmerged} > 0 )); then
        colorize_text $text_color[git_unmerged_file] "$SYMBOLS[git_unmerged_file]${unmerged} "
    fi
    if (( ${modified} > 0 )); then
        colorize_text $text_color[git_modified_file] "$SYMBOLS[git_modified_file]${modified} "
    fi
    if (( ${deleted} > 0 )); then
        colorize_text $text_color[git_deleted_file] "$SYMBOLS[git_deleted_file]${deleted} "
    fi
}

function _prompt_git_detached_HEAD_info() {
    # Get the commit hash
    git_hash="$(git rev-parse --short=20 HEAD)"
    # Return the hash
    print -n "$(colorize_text $text_color[git_hash] " $SYMBOLS[git_hash_prefix]$git_hash ")"
}

function _prompt_git_branch_upstream_info() {
    # Get branch name, upstream name
    git_HEAD_ref="$(git symbolic-ref HEAD)"
    git_branch_name="${git_HEAD_ref:11}"

    git_upstream_name="$(git rev-parse --abbrev-ref "@{upstream}" 2>/dev/null)"

    # Figure out divergence information.
    if [[ $? == 0 ]]; then
        temp="$(git rev-list --count --left-right "$git_upstream_name...HEAD")"
        behind=$(print $temp | cut -f1)
        ahead=$(print $temp | cut -f2)
    fi

    # Return the collected information, in a properly formatted manner.

    # Branch name
    print -n " "
    print -n "$(colorize_text $text_color[git_branch_name_prefix] "$SYMBOLS[git_branch_name_prefix]")"
    print -n " "
    print -n "$(colorize_text $text_color[git_branch_name] "$git_branch_name")"
    if [[ -n $git_upstream_name ]]; then
        print -n " "
        # Upstream name
        print -n "$(colorize_text $text_color[git_upstream_pointer] "$SYMBOLS[git_upstream_pointer]")"
        print -n " "
        print -n "$(colorize_text $text_color[git_upstream_name] "$git_upstream_name")"
        # Divergence text
        git_divergence=
        if (( ahead > 0 )); then
            git_divergence+=" $(colorize_text $text_color[git_deviation_ahead] "$SYMBOLS[git_deviation_ahead]$ahead")"
        fi
        if (( behind > 0 )); then
            git_divergence+=" $(colorize_text $text_color[git_deviation_behind] "$SYMBOLS[git_deviation_behind]$behind")"
        fi
        print -n $git_divergence
    fi
    print -n " "
}

#------------------------------------------------------------------------------
# Current directory
#------------------------------------------------------------------------------
function _prompt_segment_current_directory() {
    colorize_text $text_color[current_directory] "%~"
}

#------------------------------------------------------------------------------
# Current User
#------------------------------------------------------------------------------
function _prompt_segment_user_name() {
    colorize_text $text_color[user_name] "%n "
}

#------------------------------------------------------------------------------
# Virtual Environment
#------------------------------------------------------------------------------
function _prompt_segment_virtualenv() {
    venv_name=$(basename "$VIRTUAL_ENV")
    if [[ -n $venv_name ]]; then
        colorize_text $text_color[virtualenv_name] " $venv_name "
    fi
}

#------------------------------------------------------------------------------
# Background Jobs
#------------------------------------------------------------------------------
function _prompt_segment_background_job_count() {
    job_count=$(jobs -rp | wc -l)
    if [[ $job_count != '0' ]]; then
        colorize_text $text_color[background_job_count] " $SYMBOLS[background_job_count]$job_count "
    fi
}

#------------------------------------------------------------------------------
# Prompt
#------------------------------------------------------------------------------
function _prompt_show_prompt_for_input() {
    # Just show the indicator, for input.
    colorize_text $text_color[prompt_input] $SYMBOLS[prompt_input]
    print -n " "
}

#------------------------------------------------------------------------------
# Final entry point
#------------------------------------------------------------------------------
function _prompt_print() {
    _prompt_segment_user_name
    _prompt_segment_virtualenv
    _prompt_segment_background_job_count
    _prompt_segment_current_directory
    _prompt_segment_git

    print
    _prompt_show_prompt_for_input
}

export PS1='$(_prompt_print)'
# Because it's integrated...
VIRTUAL_ENV_DISABLE_PROMPT=1
